#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use FindBin '$Bin';
use Getopt::Long;
use Cwd 'abs_path';
use File::Basename;
use File::Path qw( mkpath );
use Data::Dumper;
use lib $Bin;

my ($input , $help);
my $segm = 400;
GetOptions(
	"i|input=s"	=>	\$input,
	"s|seg=s"	=>	\$segm,
	"help"	=>	\$help,
);

if ($help or ! $input){
	&help;
	exit;
}

my $virusid = " HBV_gtA HBV_gtB HBV_gtC HBV_gtD HBV_gtE HBV_gtF HBV_gtG HBV_gtH";

#A00262:57:H37FJDSXX:3:2304:19081:28588  1201    HBV_gtB 2054    10      85S65M  HBV_gtC 2382    0       CCGCAGCCACCCTGCCG
my %v;
open IN , "samtools view  -F 1024 $input $virusid | grep -P 'chr\\w+' |";
while (<IN>){
	chomp;
	my ($id,$flag,$hbv,$hbvloc,$q,$mode,$chro , @bb) = split /\t/ , $_;
	next if $mode =~ /\d+[SH].*\d+[SH]/;
	next if $mode !~ /\d+[SH]/ and $chro !~ /^chr\w+$/;
	$flag = sprintf("%b" , $flag);
	my $R;
	if ($flag =~ /1\d{6}$/){
		$R = 1;
	}else{
		$R = 2;
	}
	my $vcut = $hbvloc;
	my $ccut;
	my $chr;
	my $maplen = &maplen($mode);
	my $k = 0;
	if ($mode =~ /\d+[SH]/){
		if ($mode =~ /\d+[SH]$/){
			$vcut += $maplen-1;
		}
		for my $bb (@bb){
			#SA:Z:chr13,35020442,+,46M104S,60,0;HBV_gtC,1002,-,36M114S,0,1;
			if ($bb =~ /^SA:Z:/){
				$bb =~ s/^SA:Z://;
				$bb =~ s/;$//;
				for my $cc (split /;/ , $bb){
					if ($cc =~ /^chr/){
						my @chrbb = split /,/ , $cc;
						$ccut = $chrbb[1];
						$chr = $chrbb[0];
						if ($chrbb[3] =~ /\d+[SH]$/){
							my $ml = &maplen($chrbb[3]);
							$ccut += $ml-1;
						}
						print STDERR "$id\t$cc\t$ccut\n";
						$k = 1;
						last;
					}
				}
				last;
			}
		}
	}
	if ($k == 1){
		#		$v{"$hbv\t$vcut\t$chr\t$ccut"}->{cut}++;
		$v{"$hbv\t$chr"}->{cut}->{$ccut}->{$vcut}++;
	}else{
		$chr = $chro;
		$ccut = $bb[0];
		if ($R == 1 and $flag =~ /0\d{4}$/){
			$vcut += $maplen;
		}
		#		$v{"$hbv\t$vcut\t$chr\t$ccut"}->{pair}++;
		$v{"$hbv\t$chr"}->{pair}->{$ccut}->{$vcut}++;
	}
}
close IN;

my $bp = 2;
for my $key (sort keys %v){
	next unless exists $v{$key}->{cut};
	my ($hbv , $chr) = split /\t/ , $key;
	my @ccut = sort {$a<=>$b} keys %{$v{$key}->{cut}};
	my @pos;
	my $i = 0;
	push @{$pos[$i]} , $ccut[0];
	for my $j (1..$#ccut){
		if ($ccut[$j] <= $pos[$i]->[-1] + $bp){
			push @{$pos[$i]} , $ccut[$j];
		}else{
			$i++;
			push @{$pos[$i]} , $ccut[$j];
		}
	}
	for my $pos (@pos){
		my @cut;
		my $cn = 0;
		for my $p (@$pos){
			for my $v (sort keys %{$v{$key}->{cut}->{$p}}){
				my $count = $v{$key}->{cut}->{$p}->{$v};
				push @cut , [$p , $v , $count];
				$cn += $count;
			}
		}
		@cut = sort {$b->[2]<=>$a->[2]} @cut;
		my ($ccut , $vcut , $count) = @{$cut[0]};
		my $pn = 0;
		for my $p (sort keys %{$v{$key}->{pair}}) {
			if ($p - $segm < $ccut and $ccut < $p + $segm){
				for my $pv (sort keys %{$v{$key}->{pair}->{$p}}){
					if ($pv - $segm < $vcut and $vcut < $pv + $segm){
						$pn += $v{$key}->{pair}->{$p}->{$pv};
					}
				}
			}
		}
		print "$hbv\t$vcut\t$chr\t$ccut\t$cn\t$pn\n";
	}
}

sub maplen{
	my ($mode) = @_;
	my $len = 0;
	while ($mode =~ /(\d+)([MSHID])/g){
		if ($2 eq 'M' or $2 eq 'D'){
			$len += $1;
		}
	}
	return $len;
}

sub help{
print << "EOF!";
#===============================================================================
#
#         FILE: bamVirus.pl
#
#        USAGE: ./bamVirus.pl  
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Wang Ruiru (wangrr), wangruiru\@berrygenomics.com
# ORGANIZATION: Berry Genomics
#      VERSION: 1.0
#      CREATED: 03/14/18 15:28:16
#     REVISION: ---
#===============================================================================
EOF!
}



